import { parse } from 'cookie';import prisma from '../config/prismaClient.js';import { supabase } from '../config/supabaseClient.js';import { createClient } from 'redis';import { createAdapter } from '@socket.io/redis-adapter';// Ambil URL dari Environment (Railway akan mengisinya otomatis)const REDIS_URL = process.env.REDIS_URL;export const initSocket = async (io) => {    // --- LOGIKA PEMILIHAN ADAPTER ---    if (REDIS_URL) {        // [MODE PRODUCTION / RAILWAY]        // Jika ada URL Redis, kita connect ke sana.        console.log('ðŸš€ Mendeteksi REDIS_URL, mencoba koneksi Redis...');        const pubClient = createClient({ url: REDIS_URL });        const subClient = pubClient.duplicate();        pubClient.on('error', (err) => console.error('âŒ Redis Error:', err));        subClient.on('error', (err) => console.error('âŒ Redis Error:', err));        try {            await Promise.all([pubClient.connect(), subClient.connect()]);            io.adapter(createAdapter(pubClient, subClient));            console.log('âœ… Redis Adapter Terhubung (Mode Cluster Siap)');        } catch (error) {            console.error('âš ï¸ Gagal connect Redis, fallback ke Memory:', error);        }    } else {        // [MODE LOCAL / DEVELOPMENT]        // Jika tidak ada URL, kita pakai RAM Laptop.        console.log('â˜• Mode Development: Menggunakan RAM Laptop (Tanpa Redis)');        console.log('   (Fitur Realtime tetap jalan normal untuk testing)');    }    // --- 2. MIDDLEWARE AUTH (Sama Persis dengan sebelumnya) ---    io.use(async (socket, next) => {        try {            const cookieHeader = socket.request.headers.cookie;            if (!cookieHeader) {                return next(new Error("Authentication error: No cookies found."));            }            const cookies = parse(cookieHeader);            const accessToken = cookies['sb-access-token'];            if (!accessToken) {                return next(new Error("Authentication error: Access token missing."));            }            // Validasi ke Supabase            const { data, error } = await supabase.auth.getUser(accessToken);            if (error || !data.user) {                return next(new Error("Authentication error: Invalid or expired token."));            }            const supabaseUserId = data.user.id;            // Cek ke DB Lokal via PRISMA (Tetap diperlukan)            const localUser = await prisma.user.findUnique({                where: { id: supabaseUserId },                select: {                    id: true,                    name: true,                    email: true,                    isSuperAdmin: true,                },            });            if (!localUser) {                return next(new Error("Authentication error: User not found in local DB."));            }            socket.user = localUser;            next();        } catch (err) {            console.error("[Socket Auth] Internal Error:", err.message);            return next(new Error("Authentication error: Internal Server Error."));        }    });    // --- 3. EVENT HANDLERS (Sama Persis) ---    // Redis bekerja "di belakang layar" pada fungsi seperti socket.to().emit()    io.on("connection", (socket) => {        console.log(`ðŸŸ¢ User Connected: ${socket.user.name} (${socket.user.id})`);        socket.on("join_room", (documentId) => {            socket.join(documentId);            console.log(`User joined: ${documentId}`);        });        // Event Drag Tanda Tangan        socket.on("drag_signature", (data) => {            // Berkat Redis, event ini akan terkirim ke user lain            // meskipun mereka terkoneksi ke server backend yang berbeda.            socket.to(data.documentId).emit("update_signature_position", data);        });        socket.on("leave_room", (documentId) => {            socket.leave(documentId);            console.log(`User leave_room`);        });        socket.on("disconnect", () => {            console.log(`User Disconnected`);        });        socket.on("trigger_reload", (documentId) => {            socket.to(documentId).emit("refetch_data");        });        socket.on("add_signature_live", (data) => {            socket.to(data.documentId).emit("add_signature_live", data.signature);        });        socket.on("remove_signature_live", (data) => {            socket.to(data.documentId).emit("remove_signature_live", data.signatureId);        });        socket.on("cursor_move", (data) => {            const cursorData = {                ...data,                userId: socket.user.id,                userName: socket.user.name,            };            // Throttling sebaiknya dilakukan di client-side,            // tapi Redis mampu menangani high-throughput cursor ini.            socket.to(data.documentId).emit("cursor_move", cursorData);        });    });};