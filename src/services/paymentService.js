import midtransClient from 'midtrans-client';import crypto from 'crypto'; // [BARU] Import Crypto untuk verifikasi signatureimport CommonError from '../errors/CommonError.js';import prisma from '../config/prismaClient.js';import PaymentError from "../errors/PaymentError.js";export class PaymentService {    constructor() {        this.snap = new midtransClient.Snap({            isProduction: process.env.MIDTRANS_IS_PRODUCTION === 'true',            serverKey: process.env.MIDTRANS_SERVER_KEY,            clientKey: process.env.MIDTRANS_CLIENT_KEY        });        console.log(`[PaymentService] Initialized. Production Mode: ${process.env.MIDTRANS_IS_PRODUCTION}`);    }    /**     * Membuat transaksi pembayaran baru (Upgrade ke PREMIUM).     */    async createSubscription(userId, planType, groupId = null) {        console.log(`[PaymentService] Creating subscription for User: ${userId}, Plan: ${planType}, GroupContext: ${groupId || 'None'}`);        // 1. Ambil Data User        const user = await prisma.user.findUnique({            where: { id: userId }        });        if (!user) throw CommonError.NotFound("User tidak ditemukan.");        // 2. Tentukan Harga & Detail Produk        let amount = 0;        let productName = '';        if (planType === 'PREMIUM_MONTHLY') {            amount = 10000;            productName = 'WESIGN Pro Tier (Bulanan)';        } else if (planType === 'PREMIUM_YEARLY') {            amount = 100000;            productName = 'WESIGN Pro Tier (Tahunan)';        } else {            throw CommonError.BadRequest("Paket langganan tidak valid.");        }        // Jika upgrade dipicu dari grup, kita bisa tambahkan info di nama produk (Opsional)        if (groupId) {            productName += ' - Group Upgrade';        }        const orderId = `ORDER-${userId.substring(0, 5)}-${Date.now()}`;        console.log(`[PaymentService] Generated Order ID: ${orderId} | Amount: ${amount}`);        // 3. Buat Parameter Transaksi Midtrans        const parameter = {            transaction_details: {                order_id: orderId,                gross_amount: amount            },            item_details: [                {                    id: planType,                    price: amount,                    quantity: 1,                    name: productName                }            ],            customer_details: {                first_name: user.name,                email: user.email,                phone: user.phoneNumber || undefined            },            // [UPDATE] Sertakan groupId di custom_field jika ada            custom_field1: userId,            custom_field2: planType,            custom_field3: groupId ? String(groupId) : undefined        };        try {            // 4. Request ke Midtrans Snap API            const transaction = await this.snap.createTransaction(parameter);            console.log(`[PaymentService] Snap Token Created: ${transaction.token}`);            // 5. Simpan Transaksi PENDING ke Database Lokal            // Pastikan schema Prisma 'Transaction' Anda mendukung kolom 'groupId' jika ingin menyimpannya.            // Jika tidak, kode ini tetap aman karena 'groupId' hanya tambahan metadata logic di sini.            const transactionData = {                orderId: orderId,                amount: amount,                status: 'PENDING',                planType: planType,                snapToken: transaction.token,                snapUrl: transaction.redirect_url,                userId: userId,                // groupId: groupId ? Number(groupId) : null // [OPSIONAL] Uncomment jika schema Prisma punya kolom groupId            };            await prisma.transaction.create({                data: transactionData            });            return {                orderId,                snapToken: transaction.token,                snapUrl: transaction.redirect_url,                amount            };        } catch (error) {            console.error(`[PaymentService] Error creating transaction: ${error.message}`);            throw new PaymentError("Gagal menghubungi Midtrans.", 500);        }    }    /**     * Menangani feedback (webhook) dari Midtrans.     * [UPDATED] Menambahkan Security Check & Idempotency Check     */    async handleWebhook(notification) {        try {            console.log(`[PaymentService] Webhook Received.`);            const statusResponse = await this.snap.transaction.notification(notification);            const orderId = statusResponse.order_id;            const transactionStatus = statusResponse.transaction_status;            const fraudStatus = statusResponse.fraud_status;            const statusCode = statusResponse.status_code;            const grossAmount = statusResponse.gross_amount;            const signatureKey = statusResponse.signature_key;            console.log(`[PaymentService] Processing Order ID: ${orderId} | Status: ${transactionStatus}`);            // --- 1. SECURITY CHECK (Verifikasi Signature) ---            // Hash SHA512 dari: orderId + statusCode + grossAmount + ServerKey            const serverKey = process.env.MIDTRANS_SERVER_KEY;            const inputString = orderId + statusCode + grossAmount + serverKey;            const mySignature = crypto.createHash('sha512').update(inputString).digest('hex');            if (mySignature !== signatureKey) {                console.error(`[PaymentService] â›” Invalid Signature! Potential Fake Request.`);                throw new Error("Invalid Signature Key");            }            // --- 2. CEK DATABASE LOKAL ---            const transaction = await prisma.transaction.findUnique({                where: { orderId: orderId },                include: { user: true }            });            if (!transaction) {                console.warn(`[PaymentService] Transaction with Order ID ${orderId} not found in DB.`);                return { success: false, message: "Transaction not found" };            }            // --- 3. IDEMPOTENCY CHECK (Cek Double Process) ---            // Jika status di DB sudah SUCCESS, jangan diproses lagi agar user tidak dapat durasi ganda            if (transaction.status === 'SUCCESS') {                console.log(`[PaymentService] Transaction ${orderId} already SUCCESS. Ignoring duplicate webhook.`);                return { success: true, message: "Already processed" };            }            // --- 4. Logic Status Midtrans ---            let newStatus = transaction.status; // Default keep old status            let updateTier = false;            if (transactionStatus === 'capture') {                if (fraudStatus === 'challenge') {                    newStatus = 'CHALLENGE';                } else if (fraudStatus === 'accept') {                    newStatus = 'SUCCESS';                    updateTier = true;                }            } else if (transactionStatus === 'settlement') {                newStatus = 'SUCCESS';                updateTier = true;            } else if (transactionStatus === 'cancel' || transactionStatus === 'deny' || transactionStatus === 'expire') {                newStatus = 'FAILED';            } else if (transactionStatus === 'pending') {                newStatus = 'PENDING';            }            console.log(`[PaymentService] Determined New Status: ${newStatus} | Update Tier: ${updateTier}`);            // --- 5. Update Database (Atomic Transaction) ---            await prisma.$transaction(async (tx) => {                // A. Update Status Transaksi                await tx.transaction.update({                    where: { orderId: orderId },                    data: { status: newStatus }                });                // B. Jika Sukses, Update Status User jadi PREMIUM                if (updateTier) {                    const durationDays = transaction.planType === 'PREMIUM_YEARLY' ? 365 : 30;                    // Hitung tanggal expired                    let currentPremiumUntil = transaction.user.premiumUntil ? new Date(transaction.user.premiumUntil) : new Date();                    // Jika expired date di masa lalu, reset start date dari HARI INI                    if (currentPremiumUntil < new Date()) {                        currentPremiumUntil = new Date();                    }                    const newPremiumUntil = new Date(currentPremiumUntil);                    newPremiumUntil.setDate(newPremiumUntil.getDate() + durationDays);                    console.log(`[PaymentService] Upgrading User ${transaction.userId} until ${newPremiumUntil.toISOString()}`);                    await tx.user.update({                        where: { id: transaction.userId },                        data: {                            userStatus: 'PREMIUM',                            premiumUntil: newPremiumUntil                        }                    });                    // C. Catat Audit Log                    await tx.auditLog.create({                        data: {                            action: 'TRANSACTION_SUCCESS',                            actorId: transaction.userId,                            description: `User upgraded to PREMIUM via ${transaction.planType}. Order ID: ${orderId}`,                            ipAddress: 'System Webhook',                            userAgent: 'Midtrans'                        }                    });                }            });            console.log(`[PaymentService] Webhook processing completed successfully.`);            return { success: true };        } catch (error) {            console.error('[PaymentService] Webhook processing error:', error.message);            // Jangan throw error ke controller agar Midtrans mendapat respons 200 OK (dan berhenti retry),            // kecuali jika Anda ingin Midtrans mencoba lagi (return 500).            return { success: false, message: error.message };        }    }    async getTransactionByOrderId(orderId) {        return await prisma.transaction.findUnique({            where: { orderId }        });    }    /**     * Membatalkan transaksi.     */    async cancelTransaction(orderId, userId) {        console.log(`[PaymentService] Request to cancel Order ID: ${orderId} by User: ${userId}`);        // 1. Cek transaksi di database lokal        const transaction = await prisma.transaction.findUnique({            where: { orderId: orderId }        });        if (!transaction) throw CommonError.NotFound('Transaksi tidak ditemukan.');        if (transaction.userId !== userId) throw CommonError.Forbidden('Anda tidak memiliki akses ke transaksi ini.');        // Hanya batalkan jika status PENDING        if (transaction.status !== 'PENDING') {            console.warn(`[PaymentService] Cannot cancel transaction. Current status: ${transaction.status}`);            throw PaymentError.BadRequest('Hanya transaksi PENDING yang bisa dibatalkan.');        }        try {            // 2. Panggil API Cancel Midtrans            try {                await this.snap.transaction.cancel(orderId);                console.log(`[PaymentService] Midtrans API cancel success for Order ID: ${orderId}`);            } catch (midtransError) {                // Abaikan error 404 (Transaksi belum ada di Midtrans tapi ada di lokal)                if (midtransError.httpStatusCode == 404) {                    console.warn(`[PaymentService] Midtrans transaction not found (404), proceeding to local cancel.`);                } else {                    console.error('[PaymentService] Midtrans Cancel Error:', midtransError.message);                }            }            // 3. Update status di Database Lokal            await prisma.$transaction(async (tx) => {                await tx.transaction.update({                    where: { orderId: orderId },                    data: { status: 'CANCELLED' }                });                await tx.auditLog.create({                    data: {                        action: 'TRANSACTION_CANCELLED',                        actorId: userId,                        description: `User cancelled transaction Order ID: ${orderId}`,                        ipAddress: 'Client Request',                        userAgent: 'Web App'                    }                });            });            console.log(`[PaymentService] Transaction ${orderId} cancelled locally.`);            return { success: true, message: 'Transaksi berhasil dibatalkan.' };        } catch (error) {            console.error('[PaymentService] Cancel Transaction General Error:', error);            throw new PaymentError('Gagal membatalkan transaksi.', 500);        }    }}