import crypto from "crypto";import CommonError from "../errors/CommonError.js";import DocumentError from "../errors/DocumentError.js";/** * @typedef {object} SignaturePayload * @property {string} packageDocId - ID dokumen dalam paket (PackageDocument ID). * @property {string} signatureImageUrl - URL gambar tanda tangan yang diunggah. * @property {number} pageNumber - Nomor halaman tempat tanda tangan diletakkan. * @property {number} positionX - Posisi X (horizontal) tanda tangan dalam PDF (dalam persentase atau koordinat). * @property {number} positionY - Posisi Y (vertikal) tanda tangan dalam PDF (dalam persentase atau koordinat). * @property {number} width - Lebar tanda tangan. * @property {number} height - Tinggi tanda tangan. * @property {boolean} [displayQrCode] - Apakah QR Code verifikasi harus ditampilkan. Default: true. *//** * Service untuk mengelola proses "Signing Package" (Amplop), * termasuk pembuatan paket, pengambilan detail, dan proses penandatanganan dokumen secara massal. */export class PackageService {    /**     * Menginisialisasi PackageService dengan repository yang dibutuhkan dan PDF Service.     *     * @param {import('../repository/interface/PackageRepository.js').PackageRepository} packageRepository - Repository untuk operasi Paket.     * @param {import('../repository/interface/DocumentRepository.js').DocumentRepository} documentRepository - Repository untuk operasi Dokumen.     * @param {import('../repository/interface/VersionRepository.js').VersionRepository} versionRepository - Repository untuk operasi Versi Dokumen.     * @param {import('./PDFService.js').PDFService} pdfService - Service untuk mengelola manipulasi dan penandatanganan PDF.     * @throws {CommonError.InternalServerError} Jika salah satu dependensi tidak disediakan.     */    constructor(packageRepository, documentRepository, versionRepository, pdfService) {        if (!packageRepository || !documentRepository || !versionRepository || !pdfService) {            throw CommonError.InternalServerError(                "PackageService: Semua repository dan PDF Service harus disediakan."            );        }        this.packageRepository = packageRepository;        this.documentRepository = documentRepository;        this.versionRepository = versionRepository;        this.pdfService = pdfService;    }    /**     * Membuat paket baru yang berisi versi dokumen terbaru dari daftar ID dokumen yang diberikan.     * Dokumen yang sudah selesai ('completed') tidak dapat ditambahkan.     *     * @param {string} userId - ID pembuat paket.     * @param {string} title - Judul paket.     * @param {string[]} documentIds - Daftar ID dokumen yang akan dimasukkan ke dalam paket.     * @returns {Promise<object>} Objek paket yang baru dibuat beserta dokumen versinya.     * @throws {DocumentError.NotFound} Jika dokumen dengan ID tertentu tidak ditemukan.     * @throws {DocumentError.InvalidVersion} Jika dokumen tidak memiliki versi aktif (currentVersionId).     * @throws {CommonError.BadRequest} Jika dokumen sudah selesai atau tidak ada dokumen valid yang tersisa.     */    async createPackage(userId, title, documentIds) {        const docVersionIds = [];        for (const docId of documentIds) {            const doc = await this.documentRepository.findById(docId, userId);            if (!doc) {                throw DocumentError.NotFound(docId);            }            if (!doc.currentVersionId) {                throw DocumentError.InvalidVersion("Versi aktif tidak ditemukan", docId);            }            if (doc.status === "completed") {                throw CommonError.BadRequest(                    `Dokumen '${doc.title}' sudah selesai dan tidak dapat ditambahkan ke paket.`                );            }            docVersionIds.push(doc.currentVersionId);        }        if (docVersionIds.length === 0) {            throw CommonError.BadRequest("Tidak ada dokumen valid untuk ditambahkan ke paket.");        }        return await this.packageRepository.createPackageWithDocuments(            userId,            title,            docVersionIds        );    }    /**     * Mengambil detail lengkap sebuah paket, termasuk daftar dokumen dan versinya.     *     * @param {string} packageId - ID paket yang detailnya akan diambil.     * @param {string} userId - ID user yang memiliki paket (untuk otorisasi).     * @returns {Promise<object>} Detail lengkap objek paket.     */    async getPackageDetails(packageId, userId) {        return await this.packageRepository.findPackageById(packageId, userId);    }    /**     * Menandatangani seluruh dokumen dalam sebuah paket berdasarkan payload tanda tangan yang diberikan.     * Proses ini akan:     * 1. Memeriksa status paket.     * 2. Menyimpan data tanda tangan ke database.     * 3. Membuat URL verifikasi yang unik.     * 4. Menghasilkan file PDF yang sudah ditandatangani menggunakan PDF Service.     * 5. Menghitung hash file yang ditandatangani.     * 6. Membuat versi dokumen baru.     * 7. Memperbarui status dokumen dan paket menjadi 'completed' atau 'partial_failure'.     *     * @param {string} packageId - ID paket yang akan ditandatangani.     * @param {string} userId - ID penanda tangan.     * @param {SignaturePayload[]} signaturesPayload - Daftar tanda tangan yang akan diterapkan pada dokumen di dalam paket.     * @returns {Promise<object>} Ringkasan proses penandatanganan, mencakup status paket final, serta daftar ID dokumen yang berhasil dan gagal diproses.     * @throws {CommonError.BadRequest} Jika paket sudah selesai diproses.     */    async signPackage(packageId, userId, signaturesPayload) {        const pkg = await this.getPackageDetails(packageId, userId);        if (pkg.status === "completed") {            throw CommonError.BadRequest("Paket ini sudah selesai diproses.");        }        const results = {            success: [],            failed: [],        };        for (const packageDoc of pkg.documents) {            const originalDocId = packageDoc.docVersion.document.id;            const originalVersionId = packageDoc.docVersion.id;            try {                const signaturesForThisDoc = signaturesPayload.filter(                    (sig) => sig.packageDocId === packageDoc.id                );                if (signaturesForThisDoc.length === 0) {                    throw new Error("Dokumen tidak memiliki tanda tangan.");                }                const signaturesToCreate = signaturesForThisDoc.map((sig) => ({                    packageDocumentId: packageDoc.id,                    signerId: userId,                    signatureImageUrl: sig.signatureImageUrl,                    pageNumber: sig.pageNumber,                    positionX: sig.positionX,                    positionY: sig.positionY,                    width: sig.width,                    height: sig.height,                }));                const createdSignatures =                    await this.packageRepository.createPackageSignatures(signaturesToCreate);                if (!createdSignatures || createdSignatures.length === 0) {                    throw new Error("Gagal menyimpan data tanda tangan ke database.");                }                const firstSignatureId = createdSignatures[0].id;                const BASE_VERIFY_URL =                    process.env.VERIFICATION_URL || "http://localhost:5173";                const verificationUrl =                    `${BASE_VERIFY_URL.replace(/\/$/, "")}/verify/package/${firstSignatureId}`;                const displayQrCode =                    signaturesForThisDoc[0].displayQrCode ?? true;                const { signedFileBuffer, publicUrl } =                    await this.pdfService.generateSignedPdf(                        originalVersionId,                        signaturesForThisDoc,                        {                            displayQrCode,                            verificationUrl,                        }                    );                const signedHash = crypto                    .createHash("sha256")                    .update(signedFileBuffer)                    .digest("hex");                const newVersion = await this.versionRepository.create({                    documentId: originalDocId,                    userId,                    url: publicUrl,                    hash: signedHash,                    signedFileHash: signedHash,                });                await this.documentRepository.update(originalDocId, {                    currentVersionId: newVersion.id,                    status: "completed",                    signedFileUrl: publicUrl,                });                results.success.push(originalDocId);            } catch (error) {                console.error(                    `Gagal memproses dokumen (ID: ${originalDocId}) dalam paket ${packageId}:`,                    error                );                results.failed.push({                    documentId: originalDocId,                    error: error.message,                });            }        }        const finalStatus =            results.failed.length === 0 ? "completed" : "partial_failure";        await this.packageRepository.updatePackageStatus(packageId, finalStatus);        return {            packageId,            status: finalStatus,            ...results,        };    }}