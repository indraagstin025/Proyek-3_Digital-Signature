// File: service/PackageService.jsimport crypto from "crypto";import CommonError from "../errors/CommonError.js";import DocumentError from "../errors/DocumentError.js";/** * @typedef {object} SignaturePayload * @property {string} packageDocId - ID dari PackageDocument (dokumen spesifik dalam paket). * @property {string} signatureImageUrl - URL gambar tanda tangan (Base64/File URL). * @property {number} pageNumber - Halaman tempat tanda tangan diletakkan. * @property {number} positionX - Posisi horizontal (X). * @property {number} positionY - Posisi vertikal (Y). * @property {number} width - Lebar area tanda tangan. * @property {number} height - Tinggi area tanda tangan. * @property {boolean} [displayQrCode] - Opsi menampilkan QR Code (default: true). *//** * @class PackageService * @description Service untuk mengelola siklus hidup "Signing Package" (Amplop/Batch). */export class PackageService {    constructor(packageRepository, documentRepository, versionRepository, pdfService) {        if (!packageRepository || !documentRepository || !versionRepository || !pdfService) {            throw CommonError.InternalServerError(                "PackageService: Semua repository dan PDF Service harus disediakan."            );        }        this.packageRepository = packageRepository;        this.documentRepository = documentRepository;        this.versionRepository = versionRepository;        this.pdfService = pdfService;    }    async createPackage(userId, title, documentIds) {        const docVersionIds = [];        for (const docId of documentIds) {            const doc = await this.documentRepository.findById(docId, userId);            if (!doc) throw DocumentError.NotFound(docId);            if (!doc.currentVersionId) throw DocumentError.InvalidVersion("Versi aktif tidak ditemukan", docId);            if (doc.status === "completed") {                throw CommonError.BadRequest(                    `Dokumen '${doc.title}' sudah selesai dan tidak dapat ditambahkan ke paket.`                );            }            docVersionIds.push(doc.currentVersionId);        }        if (docVersionIds.length === 0) {            throw CommonError.BadRequest("Tidak ada dokumen valid untuk ditambahkan ke paket.");        }        return await this.packageRepository.createPackageWithDocuments(            userId,            title,            docVersionIds        );    }    async getPackageDetails(packageId, userId) {        return await this.packageRepository.findPackageById(packageId, userId);    }    /**     * Eksekusi Penandatanganan Paket (Batch Signing).     * UPDATE: Menambahkan parameter userIpAddress untuk disimpan ke DB.     */    async signPackage(packageId, userId, signaturesPayload, userIpAddress) {        const pkg = await this.getPackageDetails(packageId, userId);        if (pkg.status === "completed") {            throw CommonError.BadRequest("Paket ini sudah selesai diproses.");        }        const results = {            success: [],            failed: [],        };        for (const packageDoc of pkg.documents) {            const originalDocId = packageDoc.docVersion.document.id;            const originalVersionId = packageDoc.docVersion.id;            try {                const signaturesForThisDoc = signaturesPayload.filter(                    (sig) => sig.packageDocId === packageDoc.id                );                if (signaturesForThisDoc.length === 0) {                    throw new Error("Dokumen tidak memiliki tanda tangan yang dikonfigurasi.");                }                const signaturesToCreate = signaturesForThisDoc.map((sig) => ({                    packageDocumentId: packageDoc.id,                    signerId: userId,                    signatureImageUrl: sig.signatureImageUrl,                    pageNumber: sig.pageNumber,                    positionX: sig.positionX,                    positionY: sig.positionY,                    width: sig.width,                    height: sig.height,                    // --- MENYIMPAN IP ADDRESS ---                    ipAddress: userIpAddress,                    // ----------------------------                }));                const createdSignatures = await this.packageRepository.createPackageSignatures(signaturesToCreate);                if (!createdSignatures || createdSignatures.length === 0) {                    throw new Error("Gagal menyimpan data tanda tangan ke database.");                }                const firstSignatureId = createdSignatures[0].id;                const BASE_VERIFY_URL = process.env.VERIFICATION_URL || "http://localhost:5173";                const verificationUrl = `${BASE_VERIFY_URL.replace(/\/$/, "")}/verify/${firstSignatureId}`;                const displayQrCode = signaturesForThisDoc[0].displayQrCode ?? true;                const { signedFileBuffer, publicUrl } = await this.pdfService.generateSignedPdf(                    originalVersionId,                    signaturesForThisDoc,                    {                        displayQrCode,                        verificationUrl,                    }                );                const signedHash = crypto                    .createHash("sha256")                    .update(signedFileBuffer)                    .digest("hex");                const newVersion = await this.versionRepository.create({                    documentId: originalDocId,                    userId,                    url: publicUrl,                    hash: signedHash,                    signedFileHash: signedHash,                });                await this.packageRepository.updatePackageDocumentVersion(                    packageId,                    originalVersionId,                    newVersion.id                );                await this.documentRepository.update(originalDocId, {                    currentVersionId: newVersion.id,                    status: "completed",                    signedFileUrl: publicUrl,                });                results.success.push(originalDocId);            } catch (error) {                console.error(                    `[PackageService] Gagal memproses dokumen (ID: ${originalDocId}) dalam paket ${packageId}:`,                    error                );                results.failed.push({                    documentId: originalDocId,                    error: error.message,                });            }        }        const finalStatus = results.failed.length === 0 ? "completed" : "partial_failure";        await this.packageRepository.updatePackageStatus(packageId, finalStatus);        return {            packageId,            status: finalStatus,            ...results,        };    }    /**     * Mengambil detail verifikasi untuk SATU tanda tangan spesifik dalam paket (QR Code).     */    async getPackageSignatureVerificationDetails(signatureId) {        const pkgSignature = await this.packageRepository.findPackageSignatureById(signatureId);        if (!pkgSignature) {            return null;        }        const packageDoc = pkgSignature.packageDocument;        const docVersion = packageDoc?.docVersion;        const signer = pkgSignature.signer;        if (!docVersion || !signer) {            console.error("[PackageService] Data relasi paket tidak lengkap.");            return null;        }        const documentUrl = docVersion.url;        // Gunakan signedFileHash, jika null gunakan hash biasa        const storedHash = docVersion.signedFileHash || docVersion.hash;        if (!documentUrl || !storedHash) {            console.error(`[PackageService] Integritas Gagal (Data Kosong). URL: ${documentUrl}, Hash: ${storedHash}`);            return null;        }        let signedFileBuffer;        try {            signedFileBuffer = await this.pdfService.fileStorage.downloadFileAsBuffer(documentUrl);        } catch (fetchError) {            console.error("[PackageService] Gagal download file:", fetchError);            return null;        }        const recalculateHash = crypto.createHash("sha256").update(signedFileBuffer).digest("hex");        const isHashMatch = recalculateHash === storedHash;        const verificationStatus = isHashMatch ? "VALID (Integritas OK)" : "TIDAK VALID (Integritas GAGAL)";        return {            signerName: signer.name,            signerEmail: signer.email,            documentTitle: docVersion.document.title,            signedAt: pkgSignature.createdAt,            signatureImageUrl: pkgSignature.signatureImageUrl,            // --- TAMPILKAN IP DARI DB ---            ipAddress: pkgSignature.ipAddress || "-",            // ----------------------------            verificationStatus: verificationStatus,            storedFileHash: storedHash,            recalculatedFileHash: recalculateHash,            type: "PACKAGE"        };    }    /**     * Memverifikasi integritas file paket yang diunggah manual oleh user.     */    async verifyUploadedPackageFile(signatureId, uploadedFileBuffer) {        const pkgSignature = await this.packageRepository.findPackageSignatureById(signatureId);        if (!pkgSignature) {            return null;        }        const docVersion = pkgSignature.packageDocument?.docVersion;        const signer = pkgSignature.signer;        if (!docVersion || !signer) {            console.error("[PackageService] Data relasi paket rusak.");            return null;        }        const storedHash = docVersion.signedFileHash || docVersion.hash;        if (!storedHash) {            console.error("[PackageService] Hash database kosong.");            return null;        }        const recalculateHash = crypto.createHash("sha256").update(uploadedFileBuffer).digest("hex");        const isHashMatch = recalculateHash === storedHash;        const verificationStatus = isHashMatch ? "VALID (Integritas OK)" : "TIDAK VALID (Integritas GAGAL)";        return {            signerName: signer.name,            signerEmail: signer.email,            documentTitle: docVersion.document.title,            signedAt: pkgSignature.createdAt,            ipAddress: pkgSignature.ipAddress || "-",            verificationStatus: verificationStatus,            isSignatureValid: true,            isHashMatch: isHashMatch,            storedFileHash: storedHash,            recalculatedFileHash: recalculateHash,            type: "PACKAGE"        };    }}