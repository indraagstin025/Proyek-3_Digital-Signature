// File: service/PackageService.jsimport crypto from "crypto";import CommonError from "../errors/CommonError.js";import DocumentError from "../errors/DocumentError.js";/** * @typedef {object} SignaturePayload * @property {string} packageDocId - ID dari PackageDocument (dokumen spesifik dalam paket). * @property {string} signatureImageUrl - URL gambar tanda tangan (Base64/File URL). * @property {number} pageNumber - Halaman tempat tanda tangan diletakkan. * @property {number} positionX - Posisi horizontal (X). * @property {number} positionY - Posisi vertikal (Y). * @property {number} width - Lebar area tanda tangan. * @property {number} height - Tinggi area tanda tangan. * @property {boolean} [displayQrCode] - Opsi menampilkan QR Code (default: true). *//** * @class PackageService * @description Service untuk mengelola siklus hidup "Signing Package" (Amplop/Batch). * Service ini menangani pembuatan paket, validasi dokumen dalam paket, * dan eksekusi penandatanganan massal yang menghasilkan versi dokumen baru. */export class PackageService {    /**     * Menginisialisasi PackageService dengan dependency injection.     * * @param {import('../repository/interface/PackageRepository.js').PackageRepository} packageRepository - Repository khusus Paket.     * @param {import('../repository/interface/DocumentRepository.js').DocumentRepository} documentRepository - Repository Dokumen utama.     * @param {import('../repository/interface/VersionRepository.js').VersionRepository} versionRepository - Repository Versi Dokumen.     * @param {import('./PDFService.js').PDFService} pdfService - Service untuk manipulasi PDF (tanda tangan PAdES).     * @throws {CommonError.InternalServerError} Jika dependency wajib tidak disertakan.     */    constructor(packageRepository, documentRepository, versionRepository, pdfService) {        if (!packageRepository || !documentRepository || !versionRepository || !pdfService) {            throw CommonError.InternalServerError(                "PackageService: Semua repository dan PDF Service harus disediakan."            );        }        this.packageRepository = packageRepository;        this.documentRepository = documentRepository;        this.versionRepository = versionRepository;        this.pdfService = pdfService;    }    /**     * Membuat Paket Baru (Draft).     * Mengambil dokumen versi terbaru yang valid dan mengelompokkannya dalam satu paket.     * * @param {string} userId - ID User pembuat paket.     * @param {string} title - Judul paket (opsional).     * @param {string[]} documentIds - Array ID dokumen yang akan dimasukkan.     * @returns {Promise<object>} Objek Paket yang baru dibuat.     * @throws {DocumentError.NotFound} Jika dokumen tidak ditemukan.     * @throws {DocumentError.InvalidVersion} Jika dokumen tidak memiliki versi aktif.     * @throws {CommonError.BadRequest} Jika dokumen statusnya sudah 'completed'.     */    async createPackage(userId, title, documentIds) {        const docVersionIds = [];        for (const docId of documentIds) {            const doc = await this.documentRepository.findById(docId, userId);            if (!doc) {                throw DocumentError.NotFound(docId);            }            // Validasi: Harus punya versi aktif            if (!doc.currentVersionId) {                throw DocumentError.InvalidVersion("Versi aktif tidak ditemukan", docId);            }            // Validasi: Tidak boleh dokumen yang sudah final            if (doc.status === "completed") {                throw CommonError.BadRequest(                    `Dokumen '${doc.title}' sudah selesai dan tidak dapat ditambahkan ke paket.`                );            }            docVersionIds.push(doc.currentVersionId);        }        if (docVersionIds.length === 0) {            throw CommonError.BadRequest("Tidak ada dokumen valid untuk ditambahkan ke paket.");        }        return await this.packageRepository.createPackageWithDocuments(            userId,            title,            docVersionIds        );    }    /**     * Mengambil detail paket beserta dokumen-dokumen di dalamnya.     * * @param {string} packageId - ID Paket.     * @param {string} userId - ID User (untuk validasi akses).     * @returns {Promise<object>} Detail paket lengkap.     */    async getPackageDetails(packageId, userId) {        return await this.packageRepository.findPackageById(packageId, userId);    }    /**     * Eksekusi Penandatanganan Paket (Batch Signing).     * * Proses yang dilakukan:     * 1. Validasi status paket (tidak boleh completed).     * 2. Iterasi setiap dokumen dalam paket.     * 3. Menyimpan data posisi tanda tangan (PackageSignature).     * 4. Generate PDF Signed menggunakan PDFService.     * 5. Membuat Versi Baru (V2) di database.     * 6. **[KRITIS]** Memindahkan relasi PackageDocument dari V1 ke V2 (agar history tetap terbaca).     * 7. Mengupdate status dokumen utama menjadi 'completed'.     * 8. Mengupdate status paket berdasarkan hasil keseluruhan.     * * @param {string} packageId - ID Paket.     * @param {string} userId - ID User penanda tangan.     * @param {SignaturePayload[]} signaturesPayload - Array konfigurasi tanda tangan dari frontend.     * @returns {Promise<object>} Laporan hasil proses (success/failed list).     * @throws {CommonError.BadRequest} Jika paket sudah selesai sebelumnya.     */    async signPackage(packageId, userId, signaturesPayload) {        const pkg = await this.getPackageDetails(packageId, userId);        if (pkg.status === "completed") {            throw CommonError.BadRequest("Paket ini sudah selesai diproses.");        }        const results = {            success: [],            failed: [],        };        for (const packageDoc of pkg.documents) {            const originalDocId = packageDoc.docVersion.document.id;            const originalVersionId = packageDoc.docVersion.id;            try {                const signaturesForThisDoc = signaturesPayload.filter(                    (sig) => sig.packageDocId === packageDoc.id                );                if (signaturesForThisDoc.length === 0) {                    throw new Error("Dokumen tidak memiliki tanda tangan yang dikonfigurasi.");                }                const signaturesToCreate = signaturesForThisDoc.map((sig) => ({                    packageDocumentId: packageDoc.id,                    signerId: userId,                    signatureImageUrl: sig.signatureImageUrl,                    pageNumber: sig.pageNumber,                    positionX: sig.positionX,                    positionY: sig.positionY,                    width: sig.width,                    height: sig.height,                }));                const createdSignatures =                    await this.packageRepository.createPackageSignatures(signaturesToCreate);                if (!createdSignatures || createdSignatures.length === 0) {                    throw new Error("Gagal menyimpan data tanda tangan ke database.");                }                const firstSignatureId = createdSignatures[0].id;                const BASE_VERIFY_URL = process.env.VERIFICATION_URL || "http://localhost:5173";                const verificationUrl = `${BASE_VERIFY_URL.replace(/\/$/, "")}/verify/package/${firstSignatureId}`;                const displayQrCode = signaturesForThisDoc[0].displayQrCode ?? true;                const { signedFileBuffer, publicUrl } =                    await this.pdfService.generateSignedPdf(                        originalVersionId,                        signaturesForThisDoc,                        {                            displayQrCode,                            verificationUrl,                        }                    );                const signedHash = crypto                    .createHash("sha256")                    .update(signedFileBuffer)                    .digest("hex");                const newVersion = await this.versionRepository.create({                    documentId: originalDocId,                    userId,                    url: publicUrl,                    hash: signedHash,                    signedFileHash: signedHash,                });                await this.packageRepository.updatePackageDocumentVersion(                    packageId,                    originalVersionId,                    newVersion.id                );                await this.documentRepository.update(originalDocId, {                    currentVersionId: newVersion.id,                    status: "completed",                    signedFileUrl: publicUrl,                });                results.success.push(originalDocId);            } catch (error) {                console.error(                    `[PackageService] Gagal memproses dokumen (ID: ${originalDocId}) dalam paket ${packageId}:`,                    error                );                results.failed.push({                    documentId: originalDocId,                    error: error.message,                });            }        }        const finalStatus =            results.failed.length === 0 ? "completed" : "partial_failure";        await this.packageRepository.updatePackageStatus(packageId, finalStatus);        return {            packageId,            status: finalStatus,            ...results,        };    }}