import CommonError from "../errors/CommonError.js";import crypto from "crypto";export class GroupSignatureService {    constructor(        groupSignatureRepository,        groupDocumentSignerRepository,        documentRepository,        versionRepository,        groupMemberRepository,        pdfService,        auditService    ) {        this.groupSignatureRepository = groupSignatureRepository; // Gunakan Repo Khusus Group        this.groupDocumentSignerRepository = groupDocumentSignerRepository;        this.documentRepository = documentRepository;        this.versionRepository = versionRepository;        this.groupMemberRepository = groupMemberRepository;        this.pdfService = pdfService;        this.auditService = auditService;    }    /**     * [DRAFT] Menyimpan Draft Tanda Tangan Group (Auto-save Drag & Drop).     * Logika UPSERT (Update jika ID ada, Create jika baru).     */    async saveDraft(userId, documentId, signatureData) {        const document = await this.documentRepository.findById(documentId, userId);        if (!document) throw CommonError.NotFound(documentId);        const payload = {            id: signatureData.id, // ID dari Frontend (UUID)            userId: userId,            documentVersionId: document.currentVersionId,            status: "draft",            method: signatureData.method || "canvas",            signatureImageUrl: signatureData.signatureImageUrl,            positionX: signatureData.positionX,            positionY: signatureData.positionY,            pageNumber: signatureData.pageNumber,            width: signatureData.width || 0,            height: signatureData.height || 0,        };        console.log("[GroupService] Saving Draft:", payload.id);        // Cek apakah draft dengan ID ini sudah ada?        const existing = await this.groupSignatureRepository.findById(payload.id);        if (existing) {            // Jika ada, update posisinya saja            return await this.groupSignatureRepository.update(existing.id, payload);        } else {            // Jika belum, create baru            return await this.groupSignatureRepository.create(payload);        }    }    /**     * [UPDATE POSITION] Update posisi draft group (Drag/Resize).     */    async updateDraftPosition(signatureId, positionData) {        const updatePayload = {            positionX: positionData.positionX,            positionY: positionData.positionY,            width: positionData.width,            height: positionData.height,            pageNumber: positionData.pageNumber,        };        const updated = await this.groupSignatureRepository.update(signatureId, updatePayload);        if (!updated) {            // Opsional: Throw error 404 kalau barangnya beneran ga ada            // Tapi biasanya Frontend drag and drop lebih suka silent fail/retry            return null;        }        return updated;    }    /**     * [DELETE] Hapus Draft Group.     */    async deleteDraft(signatureId) {        const result = await this.groupSignatureRepository.delete(signatureId);        return result && result.count > 0;    }    /**     * [USER ACTION] Menandatangani Dokumen (Tanda Tangan Individu dalam Grup).     * Sebenarnya hanya mengubah status Draft -> Final.     */    async signDocument(userId, documentId, signatureData, auditData, req = null) {        // 1. Cek Hak Akses        const signerRequest = await this.groupDocumentSignerRepository.findPendingByUserAndDoc(userId, documentId);        if (!signerRequest) {            throw CommonError.BadRequest("Anda tidak memiliki akses atau sudah tanda tangan.");        }        const document = await this.documentRepository.findById(documentId, userId);        const currentVersion = document.currentVersion;        // 2. Cek apakah user sudah punya draft?        // Gunakan findBySignerAndVersion yang baru kita buat di Repo Group        const existingSignature = await this.groupSignatureRepository.findBySignerAndVersion(userId, currentVersion.id);        let finalSignature;        const payload = {            ...signatureData,            userId: userId,            documentVersionId: currentVersion.id,            status: "final", // UBAH KE FINAL            ipAddress: auditData.ipAddress,            userAgent: auditData.userAgent        };        if (existingSignature) {            finalSignature = await this.groupSignatureRepository.update(existingSignature.id, payload);        } else {            finalSignature = await this.groupSignatureRepository.create(payload);        }        // 3. Update Status Checklist Signer (Pending -> Signed)        await this.groupDocumentSignerRepository.updateStatusToSigned(documentId, userId, finalSignature.id);        // 4. Audit Log        if (this.auditService) {            await this.auditService.log("SIGN_DOCUMENT_GROUP", userId, documentId, `User menandatangani dokumen grup: ${document.title}`, req);        }        // 5. Cek Sisa Signer        const pendingCount = await this.groupDocumentSignerRepository.countPendingSigners(documentId);        return {            ...finalSignature,            message: pendingCount === 0 ? "Tanda tangan berhasil. Menunggu finalisasi Admin." : "Tanda tangan disimpan.",            isComplete: false,            readyToFinalize: pendingCount === 0,            remainingSigners: pendingCount,        };    }    /**     * [PUBLIC] Cek QR Code (Gatekeeper)     */    /**     * [PUBLIC] Cek QR Code (Gatekeeper)     * [UPDATED] Mengembalikan status locked jika dokumen memiliki Access Code.     */    async getVerificationDetails(signatureId) {        // Cari signature group berdasarkan ID        const sig = await this.groupSignatureRepository.findById(signatureId);        if (!sig) return null; // Biarkan controller lanjut cek ke service lain (Package/Personal)        // [LOGIKA BARU] Cek Kunci PIN        // Jika di database ada accessCode, kita JANGAN berikan data lengkap.        if (sig.accessCode) {            return {                isLocked: true,                signatureId: sig.id,                // Kita hanya beri judul dokumen, sisanya disembunyikan                documentTitle: sig.documentVersion?.document?.title || "Dokumen Terkunci",                type: "GROUP",                message: "Dokumen dilindungi kode akses (PIN). Silakan masukkan PIN yang tertera di dokumen."            };        }        // --- (Logika Lama: Jika TIDAK ada PIN, tampilkan seperti biasa) ---        const docVersion = sig.documentVersion;        const signer = sig.signer;        const storedHash = docVersion.signedFileHash;        // Fallback jika belum final (Scan QR sebelum admin finalize)        if (!storedHash && docVersion.document?.status !== 'completed') {            return {                documentTitle: docVersion.document.title,                verificationStatus: "PENDING_FINALIZATION",                verificationMessage: "Dokumen belum difinalisasi oleh Admin Grup.",                requireUpload: false            };        }        return {            signerName: signer.name,            signerEmail: signer.email,            signerIpAddress: sig.ipAddress || "-",            documentTitle: docVersion.document.title,            signedAt: sig.signedAt || sig.createdAt,            storedFileHash: storedHash || "PENDING",            verificationStatus: "REGISTERED",            verificationMessage: "Tanda tangan grup terdaftar.",            originalDocumentUrl: docVersion.url,            type: "GROUP",            isLocked: false // Tandai terbuka        };    }    /**     * [BARU] Membuka Kunci dengan PIN + Rate Limiting     */    async unlockVerification(signatureId, inputCode) {        const sig = await this.groupSignatureRepository.findById(signatureId);        if (!sig) return null;        // 1. CEK LOCK        if (sig.lockedUntil && new Date() < new Date(sig.lockedUntil)) {            const waitTime = Math.ceil((new Date(sig.lockedUntil) - new Date()) / 60000);            throw CommonError.Forbidden(`Dokumen terkunci sementara. Coba lagi dalam ${waitTime} menit.`);        }        // 2. JIKA PIN SALAH        if (!sig.accessCode || sig.accessCode !== inputCode) {            const newRetryCount = (sig.retryCount || 0) + 1;            const MAX_ATTEMPTS = 3;            if (newRetryCount >= MAX_ATTEMPTS) {                const lockTime = new Date(Date.now() + 30 * 60 * 1000);                await this.groupSignatureRepository.update(sig.id, {                    retryCount: newRetryCount,                    lockedUntil: lockTime                });                throw CommonError.Forbidden("Terlalu banyak percobaan salah. Dokumen dikunci selama 30 menit.");            } else {                await this.groupSignatureRepository.update(sig.id, { retryCount: newRetryCount });                const sisa = MAX_ATTEMPTS - newRetryCount;                throw CommonError.BadRequest(`PIN Salah. Sisa percobaan: ${sisa} kali.`);            }        }        // 3. JIKA PIN BENAR (Reset)        if (sig.retryCount > 0 || sig.lockedUntil) {            await this.groupSignatureRepository.update(sig.id, { retryCount: 0, lockedUntil: null });        }        // Return Data        const docVersion = sig.documentVersion;        const storedHash = docVersion.signedFileHash;        const signer = sig.signer;        return {            signerName: signer.name,            signerEmail: signer.email,            signerIpAddress: sig.ipAddress || "-",            documentTitle: docVersion.document.title,            signedAt: sig.signedAt || sig.createdAt,            storedFileHash: storedHash,            verificationStatus: "REGISTERED",            verificationMessage: "Akses diberikan. Silakan verifikasi file fisik.",            originalDocumentUrl: docVersion.url,            type: "GROUP",            isLocked: false,            requireUpload: true        };    }    /**     * [PUBLIC] Verifikasi Upload File (Final Check)     */    async verifyUploadedFile(signatureId, uploadedFileBuffer) {        const sig = await this.groupSignatureRepository.findById(signatureId);        if (!sig) return null;        // Ambil versi final dari dokumen ini        const documentId = sig.documentVersion.documentId;        // Kita butuh query ke DocumentRepository untuk dapat 'currentVersion' (Versi Final)        // Karena 'sig.documentVersion' adalah versi saat user tanda tangan (sebelum diburn).        const document = await this.documentRepository.findByIdSimple(documentId);        // Jika dokumen belum final        if(document.status !== 'completed') {            throw new Error("Dokumen grup ini belum difinalisasi oleh Admin.");        }        // Ambil hash dari versi final (currentVersion dokumen)        // Kita perlu fetch version final        const finalVersion = await this.versionRepository.findById(document.currentVersionId);        const storedHash = finalVersion.signedFileHash;        if (!storedHash) throw CommonError.InternalServerError("Data Hash dokumen final tidak ditemukan.");        // Hitung Hash file upload        const recalculateHash = crypto.createHash("sha256").update(uploadedFileBuffer).digest("hex");        const isHashMatch = recalculateHash === storedHash;        // Ambil semua penanda tangan untuk ditampilkan        const allSignatures = await this.groupSignatureRepository.findAllByVersionId(sig.documentVersionId);        // Buat string daftar nama penanda tangan (Opsional, agar terlihat keren)        const signersNames = allSignatures.map(s => s.signer.name).join(", ");        return {            signerName: sig.signer.name, // Nama pemilik QR ini            signerEmail: sig.signer.email,            ipAddress: sig.ipAddress || "-",            // Tambahan info grup            groupSigners: signersNames,            documentTitle: document.title,            signedAt: sig.createdAt,            storedFileHash: storedHash,            recalculatedFileHash: recalculateHash,            verificationStatus: isHashMatch ? "VALID" : "INVALID",            isHashMatch: isHashMatch,            type: "GROUP",        };    }}