import { PrismaClient, Prisma } from '@prisma/client';import UserRepository from '../interface/UserRepository.js';import bcrypt from 'bcrypt';const prisma = new PrismaClient();/** * @description Implementasi UserRepository menggunakan Prisma. */class PrismaUserRepository extends UserRepository {    // ================= USER =================    async createUser(userData) {        try {            const hashedPassword = await bcrypt.hash(userData.password, 10);            return await prisma.user.create({                data: {                    name: userData.name,                    email: userData.email,                    password: hashedPassword,                },                select: {                    id: true,                    name: true,                    email: true,                    createdAt: true,                },            });        } catch (error) {            if (error.code === 'P2002') {                throw new Error('Email sudah terdaftar.');            }            throw error;        }    }    async findById(id) {        if (!id || typeof id !== 'string' || !/^[0-9a-fA-F-]{36}$/.test(id)) {            throw new Error("ID user tidak valid.");        }        const user = await prisma.user.findUnique({            where: { id },            select: {                id: true,                email: true,                name: true,                phoneNumber: true,                title: true,                address: true,                profilePictureUrl: true,                isSuperAdmin: true,                createdAt: true,                updatedAt: true,            },        });        if (!user) throw new Error(`User dengan ID ${id} tidak ditemukan.`);        return user;    }    async findAll() {        return prisma.user.findMany({            select: {                id: true,                email: true,                name: true,                isSuperAdmin: true,                createdAt: true,            },            orderBy: {                createdAt: 'desc',            },        });    }    async update(id, userData) {        if (!id || typeof id !== 'string' || !/^[0-9a-fA-F-]{36}$/.test(id)) {            throw new Error("ID user tidak valid.");        }        const updateData = { ...userData };        if (updateData.password) {            updateData.password = await bcrypt.hash(updateData.password, 10);        }        try {            return await prisma.user.update({                where: { id },                data: updateData,                select: {                    id: true,                    email: true,                    name: true,                    phoneNumber: true,                    title: true,                    address: true,                    profilePictureUrl: true,                    updatedAt: true,                },            });        } catch (error) {            if (error.code === 'P2025') {                throw new Error(`User dengan ID ${id} tidak ditemukan.`);            }            throw error;        }    }    // ================= PROFILE PICTURE =================    async createProfilePicture(userId, pictureData) {        if (!userId || typeof userId !== 'string' || !/^[0-9a-fA-F-]{36}$/.test(userId)) {            throw new Error("userId harus string UUID yang valid.");        }        if (!pictureData || !pictureData.url || !pictureData.hash) {            throw new Error("Data foto tidak lengkap. Pastikan url dan hash tersedia.");        }        console.log("[DEBUG] Membuat record UserProfilePicture dengan data:", {            userId,            url: pictureData.url,            hash: pictureData.hash,            isActive: pictureData.isActive ?? false,        });        const result = await prisma.userProfilePicture.create({            data: {                userId, // âœ… gunakan string biasa                url: pictureData.url,                hash: pictureData.hash,                isActive: pictureData.isActive ?? false,            },            select: {                id: true,                url: true,                hash: true,                isActive: true,                createdAt: true,            },        });        return result;    }    async findProfilePictureByHash(userId, hash) {        return prisma.userProfilePicture.findFirst({            where: { userId, hash },        });    }    async findProfilePictureById(userId, pictureId) {        return prisma.userProfilePicture.findFirst({            where: { id: pictureId, userId },        });    }    async deactivateOtherProfilePictures(userId, activePictureId) {        return prisma.userProfilePicture.updateMany({            where: {                userId,                id: activePictureId ? { not: activePictureId } : undefined,            },            data: { isActive: false },        });    }    async setProfilePictureActive(pictureId) {        return prisma.userProfilePicture.update({            where: { id: pictureId },            data: { isActive: true },        });    }    async findAllProfilePictures(userId) {        return prisma.userProfilePicture.findMany({            where: { userId },            orderBy: { createdAt: 'desc' },        });    }    async deletePictureInTransaction(userId, pictureId, isActive) {        if (!userId || !/^[0-9a-fA-F-]{36}$/.test(userId)) {            throw new Error("ID user tidak valid.");        }        return prisma.$transaction(async (tx) => {            await tx.userProfilePicture.delete({                where: { id: pictureId },            });            if (isActive) {                await tx.user.update({                    where: { id: userId },                    data: { profilePictureUrl: null },                });            }        });    }    async deleteProfilePicture(userId, pictureId) {        return prisma.userProfilePicture.deleteMany({            where: { id: pictureId, userId },        });    }}export default PrismaUserRepository;