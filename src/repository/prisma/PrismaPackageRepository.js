// File: repository/prisma/PrismaPackageRepository.jsimport { PackageRepository } from "../interface/PackageRepository.js";import CommonError from "../../errors/CommonError.js";export class PrismaPackageRepository extends PackageRepository {    constructor(prisma) {        super();        if (!prisma) {            throw CommonError.InternalServerError("Prisma Client harus disediakan untuk PrismaPackageRepository.");        }        this.prisma = prisma;    }    /**     *     * @param userId     * @param title     * @param docVersionIds     * @returns {Promise<*>}     */    async createPackageWithDocuments(userId, title, docVersionIds) {        try {            return await this.prisma.$transaction(async (tx) => {                const newPackage = await tx.signingPackage.create({                    data: {                        userId: userId,                        title: title || "Paket Dokumen Baru",                        status: "draft",                    },                });                const packageDocumentsData = docVersionIds.map((versionId, index) => ({                    packageId: newPackage.id,                    docVersionId: versionId, // Awalnya link ke V1 (Draft)                    order: index + 1,                }));                await tx.packageDocument.createMany({                    data: packageDocumentsData,                });                return newPackage;            });        } catch (error) {            throw CommonError.DatabaseError(`Gagal membuat paket di database: ${error.message}`);        }    }    /**     *     * @param packageId     * @param userId     * @returns {Promise<awaited Prisma.Prisma__SigningPackageClient<GetResult<Prisma.$SigningPackagePayload<ExtArgs>, {where: {id: string, userId: string}, include: {documents: {orderBy: {order: string}, include: {docVersion: {include: {document: {select: {id: boolean, title: boolean}}}}}}}}, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>>}     */    async findPackageById(packageId, userId) {        try {            const pkg = await this.prisma.signingPackage.findFirst({                where: { id: packageId, userId: userId },                include: {                    documents: {                        orderBy: { order: "asc" },                        include: {                            docVersion: {                                include: {                                    document: { select: { id: true, title: true } },                                },                            },                        },                    },                },            });            if (!pkg) {                throw CommonError.NotFound(`Paket tanda tangan dengan ID '${packageId}' tidak ditemukan.`);            }            return pkg;        } catch (error) {            if (error instanceof CommonError) throw error;            throw CommonError.DatabaseError(`Gagal mencari paket: ${error.message}`);        }    }    /**     *     * @param packageId     * @param status     * @returns {Promise<awaited Prisma.Prisma__SigningPackageClient<GetResult<Prisma.$SigningPackagePayload<ExtArgs>, {where: {id: string}, data: {status: string}}, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>>}     */    async updatePackageStatus(packageId, status) {        try {            return await this.prisma.signingPackage.update({                where: { id: packageId },                data: { status: status },            });        } catch (error) {            if (error.code === 'P2025') {                throw CommonError.NotFound(`Paket dengan ID '${packageId}' tidak ditemukan untuk diupdate.`);            }            throw CommonError.DatabaseError(`Gagal update status paket: ${error.message}`);        }    }    /**     * @description Memindahkan relasi PackageDocument dari versi lama (Draft) ke versi baru (Signed).     * Method ini HARUS dipanggil oleh Service setelah PDF selesai ditandatangani dan V2 dibuat.     * * @param {string} packageId - ID Paket     * @param {string} oldVersionId - ID Versi Lama (V1)     * @param {string} newVersionId - ID Versi Baru (V2)     */    async updatePackageDocumentVersion(packageId, oldVersionId, newVersionId) {        try {            const packageDoc = await this.prisma.packageDocument.findFirst({                where: {                    packageId: packageId,                    docVersionId: oldVersionId                }            });            if (!packageDoc) {                console.warn(`[Repo] PackageDocument tidak ditemukan untuk dipindahkan. Pkg: ${packageId}, Ver: ${oldVersionId}`);                return null;            }            return await this.prisma.packageDocument.update({                where: { id: packageDoc.id },                data: {                    docVersionId: newVersionId                }            });        } catch (error) {            throw CommonError.DatabaseError(`Gagal memindahkan versi dokumen paket: ${error.message}`);        }    }    /**     *     * @param signaturesData     * @returns {Promise<Awaited<{[K in keyof UnwrapPayload<{default: Prisma.$PackageSignaturePayload<ExtArgs>}>["default"] as OmitValue<GlobalOmitOptions extends {omit: {[K in Uncapitalize<Prisma.$PackageSignaturePayload<ExtArgs>["name"]>]: infer GlobalOmit}} ? GlobalOmit : {}, K> extends true ? never : K]: UnwrapPayload<{default: Prisma.$PackageSignaturePayload<ExtArgs>}>["default"][K]} extends Function ? {[K in keyof UnwrapPayload<{default: Prisma.$PackageSignaturePayload<ExtArgs>}>["default"] as OmitValue<GlobalOmitOptions extends {omit: {[K in Uncapitalize<Prisma.$PackageSignaturePayload<ExtArgs>["name"]>]: infer GlobalOmit}} ? GlobalOmit : {}, K> extends true ? never : K]: UnwrapPayload<{default: Prisma.$PackageSignaturePayload<ExtArgs>}>["default"][K]} : {[K in keyof {[K in keyof UnwrapPayload<{default: Prisma.$PackageSignaturePayload<ExtArgs>}>["default"] as OmitValue<GlobalOmitOptions extends {omit: {[K in Uncapitalize<Prisma.$PackageSignaturePayload<ExtArgs>["name"]>]: infer GlobalOmit}} ? GlobalOmit : {}, K> extends true ? never : K]: UnwrapPayload<{default: Prisma.$PackageSignaturePayload<ExtArgs>}>["default"][K]}]: {[K in keyof UnwrapPayload<{default: Prisma.$PackageSignaturePayload<ExtArgs>}>["default"] as OmitValue<GlobalOmitOptions extends {omit: {[K in Uncapitalize<Prisma.$PackageSignaturePayload<ExtArgs>["name"]>]: infer GlobalOmit}} ? GlobalOmit : {}, K> extends true ? never : K]: UnwrapPayload<{default: Prisma.$PackageSignaturePayload<ExtArgs>}>["default"][K]}[K]}>[]>}     */    async createPackageSignatures(signaturesData) {        try {            const promises = signaturesData.map(data =>                this.prisma.packageSignature.create({ data: data })            );            return await Promise.all(promises);        } catch (error) {            throw CommonError.DatabaseError(`Gagal menyimpan data tanda tangan paket: ${error.message}`);        }    }}