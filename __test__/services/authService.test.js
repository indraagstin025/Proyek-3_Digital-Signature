// __test__/services/authService.test.jsimport { AuthService } from "../../src/services/authService.js";import AuthError from "../../src/errors/AuthError.js";import CommonError from "../../src/errors/CommonError.js";// --- Mocking External Dependencies ---// 1. Mock supabaseAuth// Gunakan LET agar jest.mock dapat mengakses variabel ini di tingkat global.let mockSupabaseAuth;// Mock file/modul supabaseAuth.js// Pindahkan definisi ke DALAM factory function agar hoisting Jest bekerja.jest.mock("../../src/config/supabaseAuth.js", () => {    mockSupabaseAuth = {        auth: {            setSession: jest.fn(),            updateUser: jest.fn(),        },    };    return mockSupabaseAuth;});// 2. Mock AuthRepositoryconst mockAuthRepository = {    registerUser: jest.fn(),    loginUser: jest.fn(),    logoutUser: jest.fn(),    forgotPassword: jest.fn(),};// --- Data Dummy ---const DUMMY_EMAIL = "test@example.com";const DUMMY_STRONG_PASSWORD = "Password123";const DUMMY_WEAK_PASSWORD = "pass";const DUMMY_ADDITIONAL_DATA = { name: "Test User" };const DUMMY_USER_RESULT = { id: "user-1", email: DUMMY_EMAIL };// --- START: Grouping Test untuk AuthService ---describe("AuthService", () => {    let authService;    // Inisialisasi service sebelum setiap test    beforeEach(() => {        // Clear semua mock, termasuk mock di dalam mockSupabaseAuth        jest.clearAllMocks();        authService = new AuthService(mockAuthRepository);    });    // --------------------------------------------------------------------------    // 0. Uji Constructor    // --------------------------------------------------------------------------    describe("Constructor", () => {        it("seharusnya membuat instance jika AuthRepository disediakan", () => {            expect(() => new AuthService(mockAuthRepository)).not.toThrow();            expect(authService.authRepository).toBe(mockAuthRepository);        });        it("seharusnya melempar CommonError jika AuthRepository tidak disediakan", () => {            expect(() => new AuthService(null)).toThrow(CommonError.InternalServerError("AuthRepository harus disediakan."));        });    });    // --------------------------------------------------------------------------    // 1. Uji registerUser    // --------------------------------------------------------------------------    describe("registerUser", () => {        it("seharusnya memanggil repository jika password valid", async () => {            // ARRANGEMENT            mockAuthRepository.registerUser.mockResolvedValue(DUMMY_USER_RESULT);            // ACT            const result = await authService.registerUser(                DUMMY_EMAIL,                DUMMY_STRONG_PASSWORD,                DUMMY_ADDITIONAL_DATA            );            // ASSERTION            expect(mockAuthRepository.registerUser).toHaveBeenCalledTimes(1);            expect(mockAuthRepository.registerUser).toHaveBeenCalledWith(                DUMMY_EMAIL,                DUMMY_STRONG_PASSWORD,                DUMMY_ADDITIONAL_DATA            );            expect(result).toBe(DUMMY_USER_RESULT);        });        it.each([            ['Password minimal 8 karakter', DUMMY_WEAK_PASSWORD],            ['Password harus mengandung minimal satu angka', 'PasswordKapital'],            ['Password harus mengandung minimal satu huruf kapital', 'password123'],            ['Password harus mengandung minimal satu huruf kecil', 'PASSWORD123'],        ])("seharusnya melempar AuthError.PasswordTooWeak jika gagal validasi: %s", async (errorMessage, password) => {            // ACT & ASSERT            await expect(authService.registerUser(DUMMY_EMAIL, password, DUMMY_ADDITIONAL_DATA))                .rejects.toThrow(AuthError.PasswordTooWeak(errorMessage));            // Verifikasi bahwa repository tidak dipanggil            expect(mockAuthRepository.registerUser).not.toHaveBeenCalled();        });    });    // --------------------------------------------------------------------------    // 2. Uji loginUser    // --------------------------------------------------------------------------    describe("loginUser", () => {        it("seharusnya memanggil authRepository.loginUser", async () => {            // ARRANGEMENT            const DUMMY_SESSION_RESULT = { session: {}, user: DUMMY_USER_RESULT };            mockAuthRepository.loginUser.mockResolvedValue(DUMMY_SESSION_RESULT);            // ACT            const result = await authService.loginUser(DUMMY_EMAIL, DUMMY_STRONG_PASSWORD);            // ASSERTION            expect(mockAuthRepository.loginUser).toHaveBeenCalledTimes(1);            expect(mockAuthRepository.loginUser).toHaveBeenCalledWith(DUMMY_EMAIL, DUMMY_STRONG_PASSWORD);            expect(result).toBe(DUMMY_SESSION_RESULT);        });    });    // --------------------------------------------------------------------------    // 3. Uji logoutUser    // --------------------------------------------------------------------------    describe("logoutUser", () => {        it("seharusnya memanggil authRepository.logoutUser", async () => {            // ARRANGEMENT            mockAuthRepository.logoutUser.mockResolvedValue(true);            // ACT            await authService.logoutUser();            // ASSERTION            expect(mockAuthRepository.logoutUser).toHaveBeenCalledTimes(1);        });    });    // --------------------------------------------------------------------------    // 4. Uji forgotPassword    // --------------------------------------------------------------------------    describe("forgotPassword", () => {        it("seharusnya memanggil authRepository.forgotPassword jika email valid", async () => {            // ARRANGEMENT            mockAuthRepository.forgotPassword.mockResolvedValue(true);            // ACT            await authService.forgotPassword(DUMMY_EMAIL);            // ASSERTION            expect(mockAuthRepository.forgotPassword).toHaveBeenCalledTimes(1);            expect(mockAuthRepository.forgotPassword).toHaveBeenCalledWith(DUMMY_EMAIL);        });        it("seharusnya melempar AuthError.UserNotFound jika email tidak disediakan", async () => {            // ACT & ASSERT            await expect(authService.forgotPassword(null))                .rejects.toThrow(AuthError.UserNotFound("Email wajib diisi."));            // Verifikasi bahwa repository tidak dipanggil            expect(mockAuthRepository.forgotPassword).not.toHaveBeenCalled();        });    });    // --------------------------------------------------------------------------    // 5. Uji resetPassword    // --------------------------------------------------------------------------    describe("resetPassword", () => {        const DUMMY_ACCESS_TOKEN = "a-token";        const DUMMY_REFRESH_TOKEN = "r-token";        const DUMMY_VALID_NEW_PASSWORD = "NewPassword123";        // Konfigurasi mock untuk sukses        beforeEach(() => {            // Pastikan mockSupabaseAuth sudah terdefinisi sebelum digunakan di sini            mockSupabaseAuth.auth.setSession.mockResolvedValue({ error: null });            mockSupabaseAuth.auth.updateUser.mockResolvedValue({ error: null });        });        it("seharusnya berhasil mereset password jika token dan password valid", async () => {            // ACT            const result = await authService.resetPassword(                DUMMY_ACCESS_TOKEN,                DUMMY_REFRESH_TOKEN,                DUMMY_VALID_NEW_PASSWORD            );            // ASSERTION            expect(mockSupabaseAuth.auth.setSession).toHaveBeenCalledTimes(1);            expect(mockSupabaseAuth.auth.setSession).toHaveBeenCalledWith({                access_token: DUMMY_ACCESS_TOKEN,                refresh_token: DUMMY_REFRESH_TOKEN,            });            expect(mockSupabaseAuth.auth.updateUser).toHaveBeenCalledTimes(1);            expect(mockSupabaseAuth.auth.updateUser).toHaveBeenCalledWith({                password: DUMMY_VALID_NEW_PASSWORD            });            expect(result).toEqual({ message: "Password berhasil diubah." });        });        it("seharusnya melempar AuthError jika accessToken atau refreshToken tidak ada", async () => {            await expect(authService.resetPassword(null, DUMMY_REFRESH_TOKEN, DUMMY_VALID_NEW_PASSWORD))                .rejects.toThrow(AuthError.ResetPasswordInvalid("Access token atau refresh token tidak ditemukan."));        });        it.each([            ['Password minimal 8 karakter', 'pass1A'],            ['Password harus mengandung minimal satu angka', 'PasswordKapital'],            ['Password harus mengandung minimal satu huruf kapital', 'password123'],        ])("seharusnya melempar AuthError.PasswordTooWeak jika password baru gagal validasi: %s", async (errorMessage, password) => {            await expect(authService.resetPassword(DUMMY_ACCESS_TOKEN, DUMMY_REFRESH_TOKEN, password))                .rejects.toThrow(AuthError.PasswordTooWeak(errorMessage));        });        it("seharusnya melempar AuthError jika setSession gagal", async () => {            // ARRANGEMENT            const SESSION_ERROR = { message: "Invalid token" };            mockSupabaseAuth.auth.setSession.mockResolvedValue({ error: SESSION_ERROR });            // ACT & ASSERT            await expect(authService.resetPassword(                DUMMY_ACCESS_TOKEN,                DUMMY_REFRESH_TOKEN,                DUMMY_VALID_NEW_PASSWORD            )).rejects.toThrow(AuthError.ResetPasswordInvalid("Tautan reset password sudah tidak valid atau kedaluwarsa."));            expect(mockSupabaseAuth.auth.updateUser).not.toHaveBeenCalled(); // Pastikan update tidak dipanggil        });        it("seharusnya melempar AuthError jika updateUser gagal", async () => {            // ARRANGEMENT            const UPDATE_ERROR = { message: "Weak password by Supabase" };            mockSupabaseAuth.auth.updateUser.mockResolvedValue({ error: UPDATE_ERROR });            // ACT & ASSERT            await expect(authService.resetPassword(                DUMMY_ACCESS_TOKEN,                DUMMY_REFRESH_TOKEN,                DUMMY_VALID_NEW_PASSWORD            )).rejects.toThrow(AuthError.ResetPasswordInvalid("Password tidak memenuhi syarat atau token sudah tidak valid."));        });    });});